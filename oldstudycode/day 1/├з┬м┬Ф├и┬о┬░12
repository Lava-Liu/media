逻辑操作符 的短路规则
+=
int i =10;
i +=20;-------i=i+20;

取反：~
把某一个数的二进制位置1
把一个数的某一个二进制位清 0
00000000 。。。。0001

#define READ 4
#define WRITE 2
#definr EXE 1
./bin/permission
输入表示文件权限的数：如 755
打印：
 user ： rwx
group： r-x
other ：r-x

a>b?a:b
int c = (a>b?a:b)
if(a>b)
{
	c = a;
}else
{

}  c=b;
逗号操作符号：
int i =2;
int a = (1,2 ,3);
int c = (i++,++i,i+10);//14
取最后一个表达式的结果

类型转换：
int i =10;
i = i +0.9897;//发生了两次类型转换
char c=256://超出范围 溢出
10 默认int型
1.23456默认double型
显示类型转换：
i = i + （int）0.9897；、//只发生一次显示类型的转换


int array[10];

关于数组名字；
	int a[5] = {1.3.4.29.20};
	sizeof（a）=20
	sizeof(a[0])=4
	sizeof(a[5])=4
	sizeof(&a[0])=4
	sizeof(&a)=4


a 和 &a[0]和&a到底有什么区别？
共同点： 以上三个值打印出来都一样
区别：
左边 = 右边
如： int a = 1
左值：表示一个可以确定的内存地址
右值：表示该内存地址上面一个确定的值

13 = b；//非法的左值
左值：数组名字a不能作为一个左值
1、不符合语法规定，数组名字是一个常量的指针，数组名字代表一整块内存空间
所以：int *p ；
	a = p；//error
	int c【10】；
        a = c ；//error
如果作为右值：
	int c = *（a+0）;//1
            c = * (a+1) ;//3
	所以：数组元素的另外一种访问方式
	可以通过数组名类似于指针的方式访问

	所以：a 和 &a 的区别
        a： a表示数组首元素的地址，此时他的意义与&a【0】等价
        &a： 表示整个数组的（起始）地址
      int a[5] = {1,3,4,29,20};
      int *p = (int*)(&a+1);
      printf("%d, %d",*(a+1),*(p-1));
 int a=7;   
7 / 2 = 3 --- 1 
3 / 2 = 1 ----1
1/  2 = 0 ---- 1
0/2 = 0  - -- -0
int bits[32];
 


栈：
   先进后出
   push（）//往栈放入一个元素
   pop（）//弹出栈顶元素
   top（）//复制栈顶元素
   size（）//栈中有多少元素
   is_empty()//判断栈中的元素是否为空
   is_full //判断栈中的元素是否满


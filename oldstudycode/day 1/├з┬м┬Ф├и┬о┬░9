数据类型：

4个字节： 0000

无符号    max:1111
          min:0000
有符号    max： 0111 通过最高位
          min： 1000  补码 取反加1 
1110 负数 
     取反  0001 
     +1    0010
-2   0010  1101 +1 1110    
= 先 -1 再取反
int 有多少位？
int  a=1;
0000....0000.....1 左移 <<
000000000000000000 = 0

0001 << 0010 
0010 << 0100
0100 << 1000
1000 << 0000


对于int型：
unsigned int：
unit_min:0
unit_max:11111111111111..1111  32ge
int:
  int_min:1000000000000000000000000..
  int_max:0111111111111111111111111..
uint_max:
  0001 ___> 1111
  0001 << 0010|1  0011
有符号最大值：
int_max:
      011111111111111111111111111111111111
int_min 1000000000000000000000000000000000 1 左移 31 次 
总结：对于有符号数， 负数二进制表示
就是该数的绝对值取反+1；
对于有符号数，负数二进制最小值其实就是正数的最大值+1





进制的字母表示：
2进制 ： 以 B 结尾
10进制 ： 23 可以以D结尾
16进制： H(Hex) 以H结尾

8进制 以 0 开头 012
16进制   0x 开头

浮点类型：
问题： 有一个浮点型数：
float data  = 0.1；
用程序判断 data 是否与 0.1相等,如果相等 打印 “data== 0.1”
否则打印 “data ！=0.1”


指针 类型
int a = 10 ；
int* p；
char* q；

//int *p = 0xff008781；
//int* p = （int*）0xff008781；
linux 下不能这么使用
int a = 11；
int * pa = &a；
int c = a;
int c = *pa；//解引用操作（间接访问）

指针是一个变量：（本身也存放在内存某个地址中）
 一般指针涉及到两个值：
   1.指针变量自身值
   2.指针变量所保存的内存地址中的值

内存地址可以用一个16进制的数表示，但是没有类型
指针是一个变量是有类型的

不管设备么类型的指针大小占的字节数是
本机地址线的大小 

int a = 10；
char c = 'a';
int *pi = &a;
char *pc = &c；
*pi 取 sizeof（int） 一般四个字节
*pc 取 sizeof（char）一般一个字节


int main(void)
{
char *p = "hellowworld\n";
printf("%s\n",p);
return 0;



}

无类型指针 
void*

 /usr/include/linux/stddef.h


保存NULL宏定义的地址

字节序的问题：
 大端字节序   低地址 放高位 高地址 放低位
小端字节序： 低地址 放低位 高地址 放高位
short int *pa = &a;

pa指向低地址。。。。


指针常量 /  常量指针
int a = 10；
char c = 'a';
const int *pi = &a；
int const *pi = &a；
const修饰*pi 所以不能通过 *pi 修改 a 的值
const int * const pi = &a；
 *pc = &c；
const 






